name: üöÄ i9 Tech CI/CD - Deploy para AWS EC2

on:
 workflow_run:
    workflows: ["üñ•Ô∏è i9 Tech CD - Entrega Cont√≠nua (Docker Build + Push)"]
    types:
      - completed
    branches: 
      - feature/aws

jobs:
  deploy:
    name: Deploy Container to EC2 via SSH
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    steps:
      - name: üîÅ Checkout do reposit√≥rio
        uses: actions/checkout@v4

      # 1) Preparar ambiente REMOTO ‚Äî remove deploy antigo (garante limpeza total)
      - name: üßπ Limpar e preparar pasta na EC2
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.REMOTE_HOST }}
          username: ${{ secrets.REMOTE_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          script: |
            set -e
            DEPLOY_DIR="/home/${{ secrets.REMOTE_USER }}/i9-application"

            # Remover tudo para evitar sobrescrita parcial (IMPORTANTE)
            if [ -d "$DEPLOY_DIR" ]; then
              rm -rf "$DEPLOY_DIR"
            fi
            mkdir -p "$DEPLOY_DIR/nginx"
            echo "Pasta de deploy limpa e recriada em $DEPLOY_DIR"

      # 2) Copiar docker-compose.yml (usamos rsync via scp action compat√≠vel)
      - name: üì¶ Copiar docker-compose.yml para EC2
        uses: easingthemes/ssh-deploy@main
        with:
          SSH_PRIVATE_KEY: ${{ secrets.EC2_SSH_KEY }}
          REMOTE_HOST: ${{ secrets.REMOTE_HOST }}
          REMOTE_USER: ${{ secrets.REMOTE_USER }}
          TARGET: /home/${{ secrets.REMOTE_USER }}/i9-application/
          SOURCE: "docker-compose.yml"
          ARGS: "-rltgoDzvO"

      # 3) Copiar pasta nginx inteira
      - name: üì¶ Copiar pasta nginx para EC2
        uses: easingthemes/ssh-deploy@main
        with:
          SSH_PRIVATE_KEY: ${{ secrets.EC2_SSH_KEY }}
          REMOTE_HOST: ${{ secrets.REMOTE_HOST }}
          REMOTE_USER: ${{ secrets.REMOTE_USER }}
          TARGET: /home/${{ secrets.REMOTE_USER }}/i9-application/
          SOURCE: "nginx"
          ARGS: "-rltgoDzvO"

      # 4) Executar deploy remoto (login, pull, down, up) ‚Äî tudo em um script idempotente
      - name: üöÄ Executar deploy na EC2 (docker compose)
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.REMOTE_HOST }}
          username: ${{ secrets.REMOTE_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          script: |
            set -euo pipefail

            DEPLOY_DIR="/home/${{ secrets.REMOTE_USER }}/i9-application"
            cd "$DEPLOY_DIR"

            # Exporta vari√°veis que o docker-compose.yml usa (substitua se quiser outra tag)
            export DOCKER_IMAGE_FULL_PATH="${{ secrets.DOCKER_REGISTRY }}/${{ secrets.DOCKER_IMAGE_NAME }}:latest"
            export IP_REMOTE_PRIVADO="${{ secrets.REMOTE_HOST_PRIVADO }}"

            echo "DOCKER_IMAGE_FULL_PATH=$DOCKER_IMAGE_FULL_PATH"

            # Gera app.conf a partir do template
            if [ -f "nginx/app.conf.template" ]; then
              envsubst '$IP_REMOTE_PRIVADO' < nginx/app.conf.template > nginx/app.conf
              echo "nginx/app.conf gerado."
            else
              echo "Aten√ß√£o: nginx/app.conf.template n√£o existe! Verifique o repo."
              exit 1
            fi

            # Fun√ß√£o para usar docker compose v2 (docker compose) quando dispon√≠vel,
            # sen√£o cair para docker-compose (compatibilidade).
            run_compose() {
              if command -v docker >/dev/null 2>&1 && docker compose version >/dev/null 2>&1; then
                DOCKER_COMPOSE_CMD="docker compose"
              elif command -v docker-compose >/dev/null 2>&1; then
                DOCKER_COMPOSE_CMD="docker-compose"
              else
                echo "ERRO: Nem 'docker compose' nem 'docker-compose' dispon√≠veis na EC2."
                exit 1
              fi
              echo "Usando: $DOCKER_COMPOSE_CMD"
            }

            run_compose

            # Fazer login no registry como root (garante que root tem credenciais).
            # Usamos sudo sh -c para rodar o login como root preservando stdin pipe.
            echo "${{ secrets.DOCKER_HUB_TOKEN }}" | sudo sh -c "docker login ${{ secrets.DOCKER_REGISTRY }} -u ${{ secrets.DOCKER_USERNAME }} --password-stdin"
            echo "Login no registry realizado (root)."

            # Pull da imagem (com a vari√°vel injetada para docker-compose substituir)
            # Passamos a vari√°vel POR ENV para o compose processar ${DOCKER_IMAGE_FULL_PATH}
            sudo env DOCKER_IMAGE_FULL_PATH="$DOCKER_IMAGE_FULL_PATH" $DOCKER_COMPOSE_CMD pull

            # Garantir que compose pare/remova containers antigos, volumes √≥rf√£os e metadados
            # Usamos --remove-orphans + -v para remover volumes associados
            sudo env DOCKER_IMAGE_FULL_PATH="$DOCKER_IMAGE_FULL_PATH" $DOCKER_COMPOSE_CMD down -v --remove-orphans || true

            # (Extra) limpar containers que sobraram com nome antigo (opcional, seguro)
            # Evita conflitos se voc√™ j√° usava container_name em algum momento
            if sudo docker ps -a --format '{{.Names}}' | grep -q '^i9-website-application$'; then
              echo "Removendo container √≥rf√£o i9-website-application"
              sudo docker rm -f i9-website-application || true
            fi

            # Sobe novamente (idempotente)
            sudo env DOCKER_IMAGE_FULL_PATH="$DOCKER_IMAGE_FULL_PATH" $DOCKER_COMPOSE_CMD up -d --force-recreate --remove-orphans
            echo "Deploy finalizado com sucesso!"

